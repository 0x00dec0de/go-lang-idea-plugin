{
  parserClass='com.goide.parser.GoParser'

  implements='com.goide.psi.GoCompositeElement'
  extends='com.goide.psi.impl.GoCompositeElementImpl'
  
  elementTypeHolderClass='com.goide.GoTypes'
  elementTypeClass='com.goide.psi.GoCompositeElementType'
  tokenTypeClass='com.goide.psi.GoTokenType'
  
  psiClassPrefix='Go'
  psiImplClassSuffix='Impl'
  psiPackage='com.goide.psi'
  psiImplPackage='com.goide.psi.impl'
  
  LBRACE               =  '{'
  RBRACE               =  '}'
  LBRACK               =  '['
  RBRACK               =  ']'
  LPAREN               =  '('
  RPAREN               =  ')'
  COLON                =  ':'
  SEMICOLON            =  ';'
  COMMA                =  ','
  EQ                   =  '=='
  ASSIGN               =  '='
  NOT_EQ               =  '!='
  NOT                  =  '!'
  PLUS_PLUS            =  '++'
  PLUS_ASSIGN          =  '+='
  PLUS                 =  '+'
  MINUS_MINUS          =  '--'
  MINUS_ASSIGN         =  '-='
  MINUS                =  '-'
  COND_OR              =  '||'
  BIT_OR_ASSIGN        =  '|='
  BIT_CLEAR_ASSIGN     =  '&^='
  BIT_CLEAR            =  '&^'
  COND_AND             =  '&&'
  BIT_AND_ASSIGN       =  '&='
  BIT_AND              =  '&'
  BIT_OR               =  '|'
  SHIFT_LEFT_ASSIGN    =  '<<='
  SHIFT_LEFT           =  '<<'
  SEND_CHANNEL         =  '<-'
  LESS_OR_EQUAL        =  '<='
  LESS                 =  '<'
  BIT_XOR_ASSIGN       =  '^='
  BIT_XOR              =  '^'
  MUL_ASSIGN           =  '*='
  MUL                  =  '*'
  QUOTIENT_ASSIGN      =  '/='
  QUOTIENT             =  '/'
  REMAINDER_ASSIGN     =  '%='
  REMAINDER            =  '%'
  SHIFT_RIGHT_ASSIGN   =  '>>='
  SHIFT_RIGHT          =  '>>'
  GREATER_OR_EQUAL     =  '>='
  GREATER              =  '>'
  VAR_ASSIGN           =  ':='
  TRIPLE_DOT           =  '...'
  DOT                  =  '.'
  SEMICOLON_SYNTHETIC  = '<NL>'
  TYPE_                = 'type'

  extends(".*(Expr|Literal|QualifiedIdentifier|identifier|Lit|OperandName)")=Expression
  pin(".*Statement")=1
  extends(".*Statement")=Statement
  extends(".*Type")=Type

  pin('.*List(?:_\d.*)?')=1
}

File ::= PackageClause semi ( ImportDeclaration semi )* ( TopLevelDeclaration semi )* {pin=1}
private semi ::= '<NL>' | ';'?

PackageClause ::= package identifier {pin=1}

ImportDeclaration ::= import ( ImportSpec | '(' ( ImportSpec semi )* ')' ) {pin(".*")=1}
ImportSpec ::= [ '.' | identifier ] string

Type ::= TypeName | TypeLit | '(' Type ')'
TypeName ::= QualifiedIdentifier | identifier
private TypeLit ::=
    ArrayOrSliceType
  | StructType
  | PointerType
  | FunctionType
  | InterfaceType
  | MapType
  | ChannelType

ArrayOrSliceType ::= '[' Expression? ']' Type {pin=1}

StructType ::= struct '{' ( FieldDeclaration semi )* '}' {pin=1}
FieldDeclaration ::= (IdentifierList Type | AnonymousField) Tag?
AnonymousField ::= '*'? TypeName
Tag ::= string

PointerType ::= '*' Type {pin=1}

FunctionType ::= func Signature {pin=1}
Signature ::= Parameters Result? {pin=1}
Result ::= Parameters | Type
Parameters ::= '(' [ ParameterList ','? ] ')' {pin(".*")=1}
private ParameterList ::= ParameterDeclaration ( ',' ParameterDeclaration )*
ParameterDeclaration ::= IdentifierListNoPin? '...'? Type

InterfaceType ::= interface '{' ( MethodSpec semi )* '}' {pin(".*")=1}
MethodSpec ::= identifier Signature | TypeName

MapType ::= map '[' Type ']' Type {pin=1}
ChannelType ::= ( chan [ '<-' ] | '<-' chan ) Type {pin(".*")='chan'}

Block ::= '{' (Statement semi)* '}' {pin(".*")=1}

Statement ::=
    ConstDeclaration
  | TypeDeclaration
  | VarDeclaration
  | LabeledStatement
  | SimpleStatement
  | GoStatement
  | ReturnStatement
  | BreakStatement
  | ContinueStatement
  | GotoStatement
  | FallthroughStatement
  | Block
  | IfStatement
  | SwitchStatement
  | SelectStatement
  | ForStatement
  | DeferStatement {recoverWhile='#auto'}

SimpleStatement ::=
    AssignmentStatement
  | SendStatement
  | ShortVarDeclaration
  | Expression ['++' | '--']

;{
  extends("(Const|Type|Var|Function|Method)Declaration")=TopLevelDeclaration
}

TopLevelDeclaration ::=
    ConstDeclaration
  | TypeDeclaration
  | VarDeclaration
  | FunctionDeclaration
  | MethodDeclaration {recoverWhile='#auto'}

ConstDeclaration ::= const ( ConstSpec | '(' ( ConstSpec semi )* ')' ) {pin(".*")=1}
ConstSpec ::= IdentifierList [ Type? '=' ExpressionList ]

private IdentifierListNoPin ::= identifier &(!('.' | ')')) (',' identifier)* // todo
private IdentifierList ::= identifier ( ',' identifier )*
private ExpressionList ::= Expression ( ',' Expression )*

TypeDeclaration ::= 'type' ( TypeSpec | '(' ( TypeSpec semi )* ')' ) {pin(".*")=1}
TypeSpec ::= identifier Type {pin=1}

VarDeclaration ::= var ( VarSpec | '(' ( VarSpec semi )* ')' ) {pin=1}
VarSpec ::= IdentifierList ( Type [ '=' ExpressionList ] | '=' ExpressionList )

ShortVarDeclaration ::= IdentifierList ':=' ExpressionList {pin=2}

FunctionDeclaration ::= func FunctionName ( Function | Signature ) {pin=2}
FunctionName ::= identifier
Function ::= Signature FunctionBody
FunctionBody ::= Block

MethodDeclaration ::= func Receiver identifier ( Function | Signature ) {pin=2 extends=FunctionDeclaration}
Receiver ::= '(' identifier? '*'? identifier ')'

Literal ::=
    int
  | float
  | floati
  | decimali
  | hex
  | oct
  | imaginary
  | rune
  | string
  | char
OperandName ::= QualifiedIdentifier | identifier

QualifiedIdentifier ::= identifier '.' identifier

CompositeLit ::= Expression LiteralValue
LiteralTypeExpr ::=
    StructType
  | ArrayOrSliceType
  | '[' '...' ']' Type
  | MapType
  | TypeName

LiteralValue ::= '{' ElementList? '}'
private ElementList  ::= Element ( ',' Element? )*
Element ::= [ Key ':' ] Value
Key ::= FieldName | ElementIndex
FieldName ::= identifier
ElementIndex ::= Expression
Value ::= Expression | LiteralValue

FunctionLit ::= func Function {pin=1}

Expression ::=
     OrExpr
  | AndExpr
  | ConditionalExpr
  | AddExpr
  | MulExpr
  | UnaryExpr
  | BuiltinCallExpr
  | MethodExpr
  | MaxGroup
  | ParenthesesExpr

OrExpr ::= Expression '||' Expression
AndExpr ::= Expression '&&' Expression
UnaryExpr ::= unary_op Expression
ConditionalExpr ::= Expression rel_op Expression
AddExpr ::= Expression add_op Expression
MulExpr ::= Expression mul_op Expression
ParenthesesExpr ::= '(' Expression ')'

BuiltinCallExpr ::= identifier '(' [ BuiltinArgs ','? ] ')'
BuiltinArgs ::= Type [ ',' ExpressionList '...'? ] | ExpressionList '...'?

private MaxGroup ::=
    OperandName
  | LiteralTypeExpr
  | ConversionExpr
  | BuiltinCallExpr
  | TypeAssertionExpr
  | SelectorExpr
  | IndexExpr
  | CallExpr
  | Literal
  | FunctionLit
  | CompositeLit

private rel_op ::= '==' | '!=' | '<' | '<=' | '>' | '>='
private add_op ::= '+' | '-' | '|' | '^'
private mul_op ::= '*' | '/' | '%' | '<<' | '>>' | '&' | '&^'
private unary_op ::= '+' | '-' | '!' | '^' | '*' | '&' | '<-'

MethodExpr ::= ReceiverType '.' identifier
ReceiverType ::= TypeName | '(' '*' TypeName ')' | '(' ReceiverType ')'
SelectorExpr ::= Expression '.' Expression
IndexExpr ::= Expression '[' IndexExprBody ']'
private IndexExprBody ::= (Expression? ':' Expression ':' Expression) | (Expression? ':' Expression?) | Expression
TypeAssertionExpr ::= Expression '.' '(' (Type | 'type') ')'
CallExpr ::= Expression ArgumentList
ArgumentList ::= '(' [ ExpressionList '...'? ','? ] ')'
ConversionExpr ::= Type '(' Expression ','? ')'

LabeledStatement ::= identifier ':' Statement {pin=2}
SendStatement ::= Expression '<-' Expression {pin=2}
AssignmentStatement ::= ExpressionList assign_op ExpressionList {pin=2}
assign_op ::= '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='
IfStatement ::= if Condition Block [ else ( IfStatement | Block ) ] {pin(".*")="if|else"}
SwitchStatement ::= ExprSwitchStatement | TypeSwitchStatement
ExprSwitchStatement ::= switch Condition '{' ( ExprCaseClause )* '}'

private Condition ::= SimpleStatementOpt [ Expression ]
private SimpleStatementOpt ::= [SimpleStatement semi]

ExprCaseClause ::= ExprSwitchCase ':' ( Statement semi )*
ExprSwitchCase ::= case ExpressionList | default {pin(".*")=1}
TypeSwitchStatement  ::= switch SimpleStatementOpt TypeSwitchGuard '{' ( TypeCaseClause )* '}'
TypeSwitchGuard ::= [ identifier ':=' ] Expression '.' '(' type ')'
TypeCaseClause ::= TypeSwitchCase ':' ( Statement semi )*
TypeSwitchCase ::= case TypeList | default {pin(".*")=1}
TypeList ::= Type ( ',' Type )*
ForStatement ::= for [ ForClause | RangeClause ] Block
ForClause ::= SimpleStatement? semi Expression semi SimpleStatement?
RangeClause ::= ( ExpressionList '=' | IdentifierList ':=' ) range Expression {pin=2}
GoStatement ::= go Expression
SelectStatement ::= select '{' ( CommClause )* '}'
CommClause ::= CommCase ':' ( Statement semi )* {pin=1}
CommCase ::= case ( SendStatement | RecvStatement ) | default {pin(".*")=1}
RecvStatement ::= [ ExpressionList '=' | IdentifierList ':=' ] Expression {pin=0}
ReturnStatement ::= return ExpressionList?
BreakStatement ::= break identifier?
ContinueStatement ::= continue identifier?
GotoStatement ::= goto identifier
FallthroughStatement ::= fallthrough
DeferStatement ::= defer Expression