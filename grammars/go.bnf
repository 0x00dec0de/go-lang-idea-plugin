{
  pin(".*List(?:_\d.*)?")=1
}

SourceFile ::= PackageClause semi ( ImportDecl semi )* ( TopLevelDecl semi )* {pin=1}
private semi ::= ";"?

PackageClause ::= "package" PackageName {pin=1}
private PackageName ::= identifier

ImportDecl ::= "import" ( ImportSpec | "(" ( ImportSpec semi )* ")" ) {pin=1}
ImportSpec ::= [ "." | PackageName ] ImportPath
ImportPath ::= string_lit

Type ::= TypeName | TypeLit | "(" Type ")"
TypeName ::= identifier | QualifiedIdent
TypeLit ::=
    ArrayType
  | StructType
  | PointerType
  | FunctionType
  | InterfaceType
  | SliceType
  | MapType
  | ChannelType

ArrayType ::= "[" ArrayLength "]" ElementType
ArrayLength ::= Expression
ElementType ::= Type
SliceType ::= "[" "]" ElementType

StructType ::= "struct" "{" ( FieldDecl semi )* "}" {pin=1}
FieldDecl ::= (IdentifierList Type | AnonymousField) [ Tag ]
AnonymousField ::= [ "*" ] TypeName
Tag ::= string_lit

PointerType ::= "*" BaseType
BaseType ::= Type

FunctionType ::= "func" Signature
Signature ::= Parameters [ Result ]
Result ::= Parameters | Type
Parameters ::= "(" [ ParameterList [ "," ] ] ")"
ParameterList ::= ParameterDecl ( "," ParameterDecl )*
ParameterDecl ::= [ IdentifierList ] [ "..." ] Type

InterfaceType ::= "interface" "{" ( MethodSpec semi )* "}"
MethodSpec ::= MethodName Signature | InterfaceTypeName
MethodName ::= identifier
InterfaceTypeName ::= TypeName

MapType ::= "map" "[" KeyType "]" ElementType
KeyType ::= Type

ChannelType ::= ( "chan" [ "<-" ] | "<-" "chan" ) ElementType

Block ::= "{" StatementList "}"
StatementList ::= ( Statement semi )* //{recoverWhile="#auto"}

Statement ::=
	  DeclarationStatement
	| LabeledStatement
	| SimpleStatement
	| GoStatement
	| ReturnStatement
	| BreakStatement
	| ContinueStatement
	| GotoStatement
	| FallthroughStatement
	| Block
	| IfStatement
	| SwitchStatement
	| SelectStatement
	| ForStatement
	| DeferStatement

SimpleStatement ::=
    ExpressionStatement
  | SendStatement
  | IncDecStatement
  | Assignment
  | ShortVarDecl

DeclarationStatement  ::= ConstDecl | TypeDecl | VarDecl
TopLevelDecl ::= DeclarationStatement | FunctionDecl | MethodDecl

ConstDecl ::= "const" ( ConstSpec | "(" ( ConstSpec semi )* ")" )
ConstSpec ::= IdentifierList [ [ Type ] "=" ExpressionList ]

IdentifierList ::= identifier ( "," identifier )*
ExpressionList ::= Expression ( "," Expression )*


TypeDecl ::= "type" ( TypeSpec | "(" ( TypeSpec semi )* ")" )
TypeSpec ::= identifier Type

VarDecl ::= "var" ( VarSpec | "(" ( VarSpec semi )* ")" )
VarSpec ::= IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList )

ShortVarDecl ::= IdentifierList ":=" ExpressionList

FunctionDecl ::= "func" FunctionName ( Function | Signature )
FunctionName ::= identifier
Function     ::= Signature FunctionBody
FunctionBody ::= Block

MethodDecl ::= "func" Receiver MethodName ( Function | Signature )
Receiver ::= "(" [ identifier ] [ "*" ] BaseTypeName ")"
BaseTypeName ::= identifier

Operand ::= Literal | OperandName | MethodExpr | "(" Expression ")"
Literal ::= BasicLit | CompositeLit | FunctionLit
BasicLit ::=
    int_lit
  | float_lit
  | imaginary_lit
  | rune_lit
  | string_lit
OperandName ::= identifier | QualifiedIdent

QualifiedIdent ::= PackageName "." identifier

CompositeLit ::= LiteralType LiteralValue
LiteralType ::=
    StructType
  | ArrayType
  | "[" "..." "]" ElementType
  | SliceType
  | MapType
  | TypeName

LiteralValue ::= "{" [ ElementList [ "," ] ] "}"
ElementList  ::= Element ( "," Element )*
Element ::= [ Key ":" ] Value
Key ::= FieldName | ElementIndex
FieldName ::= identifier
ElementIndex ::= Expression
Value ::= Expression | LiteralValue

FunctionLit ::= "func" Function

PrimaryExpr ::=
	Operand |
	Conversion |
	BuiltinCall |
	PrimaryExpr (Selector | Index | Slice | TypeAssertion | Call)

Selector ::= "." identifier
Index ::= "[" Expression "]"
Slice ::= "["
  ( [ Expression ] ":" [ Expression ] )
  | ( [ Expression ] ":" Expression ":" Expression ) "]"
TypeAssertion ::= "." "(" Type ")"
Call ::= "(" [ ArgumentList [ "," ] ] ")"
ArgumentList ::= ExpressionList [ "..." ]


Expression ::= UnaryExpr | Expression binary_op UnaryExpr
UnaryExpr ::= PrimaryExpr | unary_op UnaryExpr

binary_op  ::= "||" | "&&" | rel_op | add_op | mul_op
rel_op     ::= "==" | "!=" | "<" | "<=" | ">" | ">="
add_op     ::= "+" | "-" | "|" | "^"
mul_op     ::= "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"

unary_op   ::= "+" | "-" | "!" | "^" | "*" | "&" | "<-"

MethodExpr ::= ReceiverType "." MethodName
ReceiverType ::= TypeName | "(" "*" TypeName ")" | "(" ReceiverType ")"

Conversion ::= Type "(" Expression [ "," ] ")"

LabeledStatement ::= Label ":" Statement
Label ::= identifier

ExpressionStatement ::= Expression

SendStatement ::= Channel "<-" Expression
Channel  ::= Expression

IncDecStatement ::= Expression ( "++" | "--" )

Assignment ::= ExpressionList assign_op ExpressionList

assign_op ::= [ add_op | mul_op ] "="

IfStatement ::= "if" [ SimpleStatement semi ] Expression Block [ "else" ( IfStatement | Block ) ]

SwitchStatement ::= ExprSwitchStatement | TypeSwitchStatement

ExprSwitchStatement ::= "switch" [ SimpleStatement semi ] [ Expression ] "{" ( ExprCaseClause )* "}"
ExprCaseClause ::= ExprSwitchCase ":" StatementList
ExprSwitchCase ::= "case" ExpressionList | "default"

TypeSwitchStatement  ::= "switch" [ SimpleStatement semi ] TypeSwitchGuard "{" ( TypeCaseClause )* "}"
TypeSwitchGuard ::= [ identifier ":=" ] PrimaryExpr "." "(" "type" ")"
TypeCaseClause  ::= TypeSwitchCase ":" StatementList
TypeSwitchCase  ::= "case" TypeList | "default"
TypeList        ::= Type ( "," Type )*

ForStatement ::= "for" [ Expression | RangeClause | ForClause ] Block

ForClause ::= SimpleStatement? semi Expression? semi SimpleStatement?

RangeClause ::= ( ExpressionList "=" | IdentifierList ":=" ) "range" Expression

GoStatement ::= "go" Expression

SelectStatement ::= "select" "{" ( CommClause )* "}"
CommClause ::= CommCase ":" StatementList
CommCase   ::= "case" ( SendStatement | RecvStatement ) | "default"
RecvStatement   ::= [ ExpressionList "=" | IdentifierList ":=" ] Expression

ReturnStatement ::= "return" [ ExpressionList ]

BreakStatement ::= "break" Label?
ContinueStatement ::= "continue" Label?
GotoStatement ::= "goto" Label
FallthroughStatement ::= "fallthrough"
DeferStatement ::= "defer" Expression

BuiltinCall ::= identifier "(" [ BuiltinArgs [ "," ] ] ")"
BuiltinArgs ::= Type [ "," ArgumentList ] | ArgumentList

