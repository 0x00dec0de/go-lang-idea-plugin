{
  parserClass='com.goide.parser.GoParser'

  implements='com.goide.psi.GoCompositeElement'
  extends='com.goide.psi.impl.GoCompositeElementImpl'
  
  elementTypeHolderClass='com.goide.GoTypes'
  elementTypeClass='com.goide.psi.GoCompositeElementType'
  tokenTypeClass='com.goide.psi.GoTokenType'
  
  psiClassPrefix='Go'
  psiImplClassSuffix='Impl'
  psiPackage='com.goide.psi'
  psiImplPackage='com.goide.psi.impl'
  
  LBRACE               =  '{'
  RBRACE               =  '}'
  LBRACK               =  '['
  RBRACK               =  ']'
  LPAREN               =  '('
  RPAREN               =  ')'
  COLON                =  ':'
  SEMICOLON            =  ';'
  COMMA                =  ','
  EQ                   =  '=='
  ASSIGN               =  '='
  NOT_EQ               =  '!='
  NOT                  =  '!'
  PLUS_PLUS            =  '++'
  PLUS_ASSIGN          =  '+='
  PLUS                 =  '+'
  MINUS_MINUS          =  '--'
  MINUS_ASSIGN         =  '-='
  MINUS                =  '-'
  COND_OR              =  '||'
  BIT_OR_ASSIGN        =  '|='
  BIT_CLEAR_ASSIGN     =  '&^='
  BIT_CLEAR            =  '&^'
  COND_AND             =  '&&'
  BIT_AND_ASSIGN       =  '&='
  BIT_AND              =  '&'
  BIT_OR               =  '|'
  SHIFT_LEFT_ASSIGN    =  '<<='
  SHIFT_LEFT           =  '<<'
  SEND_CHANNEL         =  '<-'
  LESS_OR_EQUAL        =  '<='
  LESS                 =  '<'
  BIT_XOR_ASSIGN       =  '^='
  BIT_XOR              =  '^'
  MUL_ASSIGN           =  '*='
  MUL                  =  '*'
  QUOTIENT_ASSIGN      =  '/='
  QUOTIENT             =  '/'
  REMAINDER_ASSIGN     =  '%='
  REMAINDER            =  '%'
  SHIFT_RIGHT_ASSIGN   =  '>>='
  SHIFT_RIGHT          =  '>>'
  GREATER_OR_EQUAL     =  '>='
  GREATER              =  '>'
  VAR_ASSIGN           =  ':='
  TRIPLE_DOT           =  '...'
  DOT                  =  '.'
  SEMICOLON_SYNTHETIC  = '<NL>'
  TYPE_                = 'type'

  extends(".*(Expr|Literal|QualifiedIdent|identifier|Lit|OperandName)")=Expression
  pin(".*Statement")=1
  extends(".*Statement")=Statement
  extends(".*Type")=Type

  pin('.*List(?:_\d.*)?')=1
}

File ::= PackageClause semi ( ImportDeclaration semi )* ( TopLevelDeclaration semi )* {pin=1}
private semi ::= '<NL>' | ';'?

PackageClause ::= package PackageName {pin=1}
private PackageName ::= identifier

ImportDeclaration ::= import ( ImportSpec | '(' ( ImportSpec semi )* ')' ) {pin=1}
ImportSpec ::= [ '.' | PackageName ] string

Type ::= TypeName | TypeLit | '(' Type ')' {pin(".*")=1}
TypeName ::= identifier | QualifiedIdent
TypeLit ::=
    ArrayOrSliceType
  | StructType
  | PointerType
  | FunctionType
  | InterfaceType
  | MapType
  | ChannelType

ArrayOrSliceType ::= '[' Expression? ']' Type {pin=1}

StructType ::= struct '{' ( FieldDeclaration semi )* '}' {pin=1}
FieldDeclaration ::= (IdentifierList Type | AnonymousField) [ Tag ]
AnonymousField ::= [ '*' ] TypeName
Tag ::= string

PointerType ::= '*' BaseType
BaseType ::= Type

FunctionType ::= func Signature
Signature ::= Parameters [ Result ]
Result ::= Parameters | Type
Parameters ::= '(' [ ParameterList [ ',' ] ] ')'
private ParameterList ::= ParameterDeclaration ( ',' ParameterDeclaration )*
ParameterDeclaration ::= [ IdentifierList ] [ '...' ] Type

InterfaceType ::= interface '{' ( MethodSpec semi )* '}' {pin(".*")=1}
MethodSpec ::= identifier Signature | InterfaceTypeName
InterfaceTypeName ::= TypeName

MapType ::= map '[' Type ']' Type {pin=1}

ChannelType ::= ( chan [ '<-' ] | '<-' chan ) Type {pin(".*")='chan'}

Block ::= '{' (Statement semi)* '}' {pin(".*")=1}

Statement ::=
	  ConstDeclaration
	| TypeDeclaration
	| VarDeclaration
	| LabeledStatement
	| SimpleStatement
	| GoStatement
	| ReturnStatement
	| BreakStatement
	| ContinueStatement
	| GotoStatement
	| FallthroughStatement
	| Block
	| IfStatement
	| SwitchStatement
	| SelectStatement
	| ForStatement
	| DeferStatement {recoverWhile="#auto"}

SimpleStatement ::=
    AssignmentStatement
  | SendStatement
  | ShortVarDeclaration
  | Expression ['++' | '--']

;{
  extends("(Const|Type|Var|Function|Method)Declaration")=TopLevelDeclaration
}

TopLevelDeclaration ::=
    ConstDeclaration
  | TypeDeclaration
  | VarDeclaration
  | FunctionDeclaration
  | MethodDeclaration

ConstDeclaration ::= const ( ConstSpec | '(' ( ConstSpec semi )* ')' ) {pin(".*")=1}
ConstSpec ::= IdentifierList [ [ Type ] '=' ExpressionList ]

private IdentifierList ::= identifier ( ',' identifier )*
private ExpressionList ::= Expression ( ',' Expression )*

TypeDeclaration ::= 'type' ( TypeSpec | '(' ( TypeSpec semi )* ')' ) {pin(".*")=1}
TypeSpec ::= identifier Type {pin=1}

VarDeclaration ::= var ( VarSpec | '(' ( VarSpec semi )* ')' ) {pin=1}
VarSpec ::= IdentifierList ( Type [ '=' ExpressionList ] | '=' ExpressionList )

ShortVarDeclaration ::= IdentifierList ':=' ExpressionList

FunctionDeclaration ::= func FunctionName ( Function | Signature ) {pin=2}
FunctionName ::= identifier
Function ::= Signature FunctionBody
FunctionBody ::= Block

MethodDeclaration ::= func Receiver identifier ( Function | Signature ) {pin=2}
Receiver ::= '(' [ identifier ] [ '*' ] identifier ')'

Literal ::=
    int
  | float
  | floati
  | decimali
  | hex
  | oct
  | imaginary
  | rune
  | string
OperandName ::= identifier | QualifiedIdent

QualifiedIdent ::= PackageName '.' identifier

CompositeLit ::= Expression LiteralValue
LiteralTypeExpr ::=
    StructType
  | ArrayOrSliceType
  | '[' '...' ']' Type
  | MapType
  | TypeName

LiteralValue ::= '{' [ ElementList [ ',' ] ] '}'
private ElementList  ::= Element ( ',' Element )*
Element ::= [ Key ':' ] Value
Key ::= FieldName | ElementIndex
FieldName ::= identifier
ElementIndex ::= Expression
Value ::= Expression | LiteralValue

FunctionLit ::= func Function {pin=1}

Expression ::=
       OrExpr
    | AndExpr
    | ConditionalExpr
    | AddExpr
    | MulExpr
    | UnaryExpr
    | BuiltinCallExpr
    | MethodExpr
    | MaxGroup
    | ParentheziedExpr

OrExpr ::= Expression '||' Expression
AndExpr ::= Expression '&&' Expression
UnaryExpr ::= unary_op Expression
ConditionalExpr ::= Expression rel_op Expression
AddExpr ::= Expression add_op Expression
MulExpr ::= Expression mul_op Expression
ParentheziedExpr ::= '(' Expression ')'

BuiltinCallExpr ::= identifier '(' [ BuiltinArgs [ ',' ] ] ')' {pin=2}
BuiltinArgs ::= Type [ ',' ExpressionList '...'? ] | ExpressionList '...'?

private MaxGroup ::=
      OperandName
    | LiteralTypeExpr
    | ConversionExpr
    | BuiltinCallExpr
    | SelectorExpr
    | IndexExpr
    | SliceExpr
    | TypeAssertionExpr
    | CallExpr
    | Literal
    | FunctionLit
    | CompositeLit

private rel_op     ::= '==' | '!=' | '<' | '<=' | '>' | '>='
private add_op     ::= '+' | '-' | '|' | '^'
private mul_op     ::= '*' | '/' | '%' | '<<' | '>>' | '&' | '&^'
private unary_op   ::= '+' | '-' | '!' | '^' | '*' | '&' | '<-'

MethodExpr ::= ReceiverType '.' identifier
ReceiverType ::= TypeName | '(' '*' TypeName ')' | '(' ReceiverType ')'
SelectorExpr ::= Expression '.' Expression
IndexExpr ::= Expression '[' Expression ']'
SliceExpr ::= Expression ('[' ( [ Expression ] ':' [ Expression ] ) | ( [ Expression ] ':' Expression ':' Expression ) ']')
TypeAssertionExpr ::= Expression '.' '(' Type ')'
CallExpr ::= Expression ArgumentList
ArgumentList ::= '(' [ ExpressionList '...'? ','? ] ')'
ConversionExpr ::= Type '(' Expression [ ',' ] ')'

LabeledStatement ::= identifier ':' Statement {pin=0}
SendStatement ::= Expression '<-' Expression {pin=2}
AssignmentStatement ::= ExpressionList assign_op ExpressionList {pin=2}
assign_op ::= '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='
IfStatement ::= if [ SimpleStatement semi ] Expression Block [ else ( IfStatement | Block ) ] {pin(".*")="if|else"}
SwitchStatement ::= ExprSwitchStatement | TypeSwitchStatement
ExprSwitchStatement ::= switch [ SimpleStatement semi ] [ Expression ] '{' ( ExprCaseClause )* '}'
ExprCaseClause ::= ExprSwitchCase ':' ( Statement semi )*
ExprSwitchCase ::= case ExpressionList | default {pin(".*")=1}
TypeSwitchStatement  ::= switch [ SimpleStatement semi ] TypeSwitchGuard '{' ( TypeCaseClause )* '}'
TypeSwitchGuard ::= [ identifier ':=' ] Expression '.' '(' type ')'
TypeCaseClause ::= TypeSwitchCase ':' ( Statement semi )*
TypeSwitchCase ::= case TypeList | default {pin(".*")=1}
TypeList ::= Type ( ',' Type )*
ForStatement ::= for [ Expression | RangeClause | ForClause ] Block
ForClause ::= SimpleStatement? semi Expression? semi SimpleStatement?
RangeClause ::= ( ExpressionList '=' | IdentifierList ':=' ) range Expression {pin=2}
GoStatement ::= go Expression
SelectStatement ::= select '{' ( CommClause )* '}'
CommClause ::= CommCase ':' ( Statement semi )* {pin=1}
CommCase ::= case ( SendStatement | RecvStatement ) | default {pin(".*")=1}
RecvStatement ::= [ ExpressionList '=' | IdentifierList ':=' ] Expression {pin=0}
ReturnStatement ::= return [ ExpressionList ]
BreakStatement ::= break identifier?
ContinueStatement ::= continue identifier?
GotoStatement ::= goto identifier
FallthroughStatement ::= fallthrough
DeferStatement ::= defer Expression
