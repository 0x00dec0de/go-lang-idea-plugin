{
  parserClass='com.goide.parser.GoParser'

  implements='com.goide.psi.GoCompositeElement'
  extends='com.goide.psi.impl.GoCompositeElementImpl'
  
  elementTypeHolderClass='com.goide.GoTypes'
  elementTypeClass='com.goide.psi.GoCompositeElementType'
  tokenTypeClass='com.goide.psi.GoTokenType'
  
  psiClassPrefix='Go'
  psiImplClassSuffix='Impl'
  psiPackage='com.goide.psi'
  psiImplPackage='com.goide.psi.impl'
  
  LBRACE               =  '{'
  RBRACE               =  '}'
  LBRACK               =  '['
  RBRACK               =  ']'
  LPAREN               =  '('
  RPAREN               =  ')'
  COLON                =  ':'
  SEMICOLON            =  ';'
  COMMA                =  ','
  EQ                   =  '=='
  ASSIGN               =  '='
  NOT_EQ               =  '!='
  NOT                  =  '!'
  PLUS_PLUS            =  '++'
  PLUS_ASSIGN          =  '+='
  PLUS                 =  '+'
  MINUS_MINUS          =  '--'
  MINUS_ASSIGN         =  '-='
  MINUS                =  '-'
  COND_OR              =  '||'
  BIT_OR_ASSIGN        =  '|='
  BIT_CLEAR_ASSIGN     =  '&^='
  BIT_CLEAR            =  '&^'
  COND_AND             =  '&&'
  BIT_AND_ASSIGN       =  '&='
  BIT_AND              =  '&'
  BIT_OR               =  '|'
  SHIFT_LEFT_ASSIGN    =  '<<='
  SHIFT_LEFT           =  '<<'
  SEND_CHANNEL         =  '<-'
  LESS_OR_EQUAL        =  '<='
  LESS                 =  '<'
  BIT_XOR_ASSIGN       =  '^='
  BIT_XOR              =  '^'
  MUL_ASSIGN           =  '*='
  MUL                  =  '*'
  QUOTIENT_ASSIGN      =  '/='
  QUOTIENT             =  '/'
  REMAINDER_ASSIGN     =  '%='
  REMAINDER            =  '%'
  SHIFT_RIGHT_ASSIGN   =  '>>='
  SHIFT_RIGHT          =  '>>'
  GREATER_OR_EQUAL     =  '>='
  GREATER              =  '>'
  VAR_ASSIGN           =  ':='
  TRIPLE_DOT           =  '...'
  DOT                  =  '.'
  SEMICOLON_SYNTHETIC  = '<NL>'

  extends(".*(Expr|Literal|QualifiedIdent|identifier|Lit|OperandName)")=Expression
  pin(".*Statement")=1

  pin('.*List(?:_\d.*)?')=1
}

SourceFile ::= PackageClause semi ( ImportDecl semi )* ( TopLevelDecl semi )* {pin=1}
private semi ::= '<NL>' | ';'?

PackageClause ::= package PackageName {pin=1}
private PackageName ::= identifier

ImportDecl ::= import ( ImportSpec | '(' ( ImportSpec semi )* ')' ) {pin=1}
ImportSpec ::= [ '.' | PackageName ] ImportPath
ImportPath ::= string

GoType ::= TypeName | TypeLit | '(' GoType ')'
TypeName ::= identifier | QualifiedIdent
TypeLit ::=
    ArrayType
  | StructType
  | PointerType
  | FunctionType
  | InterfaceType
  | SliceType
  | MapType
  | ChannelType

ArrayType ::= '[' ArrayLength ']' ElementType
ArrayLength ::= Expression
ElementType ::= GoType
SliceType ::= '[' ']' ElementType

StructType ::= struct '{' ( FieldDecl semi )* '}' {pin=1}
FieldDecl ::= (IdentifierList GoType | AnonymousField) [ Tag ]
AnonymousField ::= [ '*' ] TypeName
Tag ::= string

PointerType ::= '*' BaseType
BaseType ::= GoType

FunctionType ::= func Signature
Signature ::= Parameters [ Result ]
Result ::= Parameters | GoType
Parameters ::= '(' [ ParameterList [ ',' ] ] ')'
ParameterList ::= ParameterDecl ( ',' ParameterDecl )*
ParameterDecl ::= [ IdentifierList ] [ '...' ] GoType

InterfaceType ::= interface '{' ( MethodSpec semi )* '}'
MethodSpec ::= MethodName Signature | InterfaceTypeName
MethodName ::= identifier
InterfaceTypeName ::= TypeName

MapType ::= map '[' KeyType ']' ElementType
KeyType ::= GoType

ChannelType ::= ( chan [ '<-' ] | '<-' chan ) ElementType

Block ::= '{' rule* '}' {pin(".*")=1}
private rule ::= Statement semi {pin=1}

Statement ::=
	  DeclarationStatement
	| LabeledStatement
	| SimpleStatement
	| GoStatement
	| ReturnStatement
	| BreakStatement
	| ContinueStatement
	| GotoStatement
	| FallthroughStatement
	| Block
	| IfStatement
	| SwitchStatement
	| SelectStatement
	| ForStatement
	| DeferStatement

SimpleStatement ::=
    ExpressionStatement
  | SendStatement
  | IncDecStatement
  | AssignmentStatement
  | ShortVarDecl

DeclarationStatement  ::= ConstDecl | TypeDecl | VarDecl
TopLevelDecl ::= DeclarationStatement | FunctionDecl | MethodDecl

ConstDecl ::= const ( ConstSpec | '(' ( ConstSpec semi )* ')' ) {pin(".*")=1}
ConstSpec ::= IdentifierList [ [ GoType ] '=' ExpressionList ]

IdentifierList ::= identifier ( ',' identifier )*
ExpressionList ::= Expression ( ',' Expression )*

TypeDecl ::= type ( TypeSpec | '(' ( TypeSpec semi )* ')' ) {pin(".*")=1}
TypeSpec ::= identifier GoType {pin=1}

VarDecl ::= var ( VarSpec | '(' ( VarSpec semi )* ')' ) {pin=1}
VarSpec ::= IdentifierList ( GoType [ '=' ExpressionList ] | '=' ExpressionList )

ShortVarDecl ::= IdentifierList ':=' ExpressionList

FunctionDecl ::= func FunctionName ( Function | Signature )
FunctionName ::= identifier
Function     ::= Signature FunctionBody
FunctionBody ::= Block

MethodDecl ::= func Receiver MethodName ( Function | Signature ) {pin=1}
Receiver ::= '(' [ identifier ] [ '*' ] identifier ')'

private Operand ::= Literal | MethodExpr | OperandName
Literal ::= BasicLit | FunctionLit | CompositeLit
private BasicLit ::= // todo
    int
  | float
  | float_i
  | decimal_i
  | hex
  | oct
  | imaginary
  | rune
  | string
OperandName ::= identifier | QualifiedIdent

QualifiedIdent ::= PackageName '.' identifier

CompositeLit ::= LiteralType LiteralValue
LiteralType ::=
    StructType
  | ArrayType
  | '[' '...' ']' ElementType
  | SliceType
  | MapType
  | TypeName

LiteralValue ::= '{' [ ElementList [ ',' ] ] '}'
ElementList  ::= Element ( ',' Element )*
Element ::= [ Key ':' ] Value
Key ::= FieldName | ElementIndex
FieldName ::= identifier
ElementIndex ::= Expression
Value ::= Expression | LiteralValue

FunctionLit ::= func Function

Expression ::=
       OrExpr
    | AndExpr
    | ConditionalExpr
    | AddExpr
    | MulExpr
    | UnaryExpr
    | BuiltinCallExpr
    | MethodExpr
    | MaxGroup
    | ParentheziedExpr


OrExpr ::= Expression '||' Expression
AndExpr ::= Expression '&&' Expression
UnaryExpr ::= unary_op Expression
ConditionalExpr ::= Expression rel_op Expression
AddExpr ::= Expression add_op Expression
MulExpr ::= Expression mul_op Expression
ParentheziedExpr ::= '(' Expression ')'

BuiltinCallExpr ::= identifier '(' [ BuiltinArgs [ ',' ] ] ')' {pin=2}
BuiltinArgs ::= GoType [ ',' ArgumentList ] | ArgumentList


private MaxGroup ::=
      Operand
    | ConversionExpr
    | BuiltinCallExpr
//    PrimaryExpr (Selector | Index | Slice | TypeAssertion | Call)
//UnaryExpr ::= PrimaryExpr | unary_op UnaryExpr

//binary_op  ::= '||' | '&&' | rel_op | add_op | mul_op
private rel_op     ::= '==' | '!=' | '<' | '<=' | '>' | '>='
private add_op     ::= '+' | '-' | '|' | '^'
private mul_op     ::= '*' | '/' | '%' | '<<' | '>>' | '&' | '&^'
private unary_op   ::= '+' | '-' | '!' | '^' | '*' | '&' | '<-'

MethodExpr ::= ReceiverType '.' MethodName
ReceiverType ::= TypeName | '(' '*' TypeName ')' | '(' ReceiverType ')'

//PrimaryExpr ::=
//
//
//Selector ::= '.' identifier
//Index ::= '[' Expression ']'
//Slice ::= '['
//  ( [ Expression ] ':' [ Expression ] )
//  | ( [ Expression ] ':' Expression ':' Expression ) ']'
//TypeAssertion ::= '.' '(' GoType ')'
//Call ::= '(' [ ArgumentList [ ',' ] ] ')'
ArgumentList ::= ExpressionList '...'?
//
ConversionExpr ::= GoType '(' Expression [ ',' ] ')'

LabeledStatement ::= identifier ':' Statement {pin=2}

ExpressionStatement ::= Expression

SendStatement ::= Expression '<-' Expression {pin=2}
IncDecStatement ::= Expression ( '++' | '--' )

AssignmentStatement ::= ExpressionList assign_op ExpressionList {pin=2}

assign_op ::= '=' | '+=' | '-=' | '|=' | '^=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '&^='

IfStatement ::= if [ SimpleStatement semi ] Expression Block [ else ( IfStatement | Block ) ]

SwitchStatement ::= ExprSwitchStatement | TypeSwitchStatement

ExprSwitchStatement ::= switch [ SimpleStatement semi ] [ Expression ] '{' ( ExprCaseClause )* '}'
ExprCaseClause ::= ExprSwitchCase ':' ( Statement semi )*
ExprSwitchCase ::= case ExpressionList | default

TypeSwitchStatement  ::= switch [ SimpleStatement semi ] TypeSwitchGuard '{' ( TypeCaseClause )* '}'
TypeSwitchGuard ::= [ identifier ':=' ] Expression '.' '(' type ')'
TypeCaseClause  ::= TypeSwitchCase ':' ( Statement semi )*
TypeSwitchCase  ::= case TypeList | default
TypeList        ::= GoType ( ',' GoType )*

ForStatement ::= for [ Expression | RangeClause | ForClause ] Block
ForClause ::= SimpleStatement? semi Expression? semi SimpleStatement?
RangeClause ::= ( ExpressionList '=' | IdentifierList ':=' ) range Expression {pin=2}

GoStatement ::= go Expression

SelectStatement ::= select '{' ( CommClause )* '}'
CommClause ::= CommCase ':' ( Statement semi )*
CommCase   ::= case ( SendStatement | RecvStatement ) | default
RecvStatement   ::= [ ExpressionList '=' | IdentifierList ':=' ] Expression

ReturnStatement ::= return [ ExpressionList ]

BreakStatement ::= break identifier?
ContinueStatement ::= continue identifier?
GotoStatement ::= goto identifier
FallthroughStatement ::= fallthrough
DeferStatement ::= defer Expression
